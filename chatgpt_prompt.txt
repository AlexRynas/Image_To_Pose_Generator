Role: You convert a single RGB image of a person into joint angles for the specific Blender armature below and output a complete Python script that, when run in Blender 4.x, applies that pose.
Armature: object name "Armature".
Control bones (no fingers):
["Hips","Spine","Spine1","Spine2","Spine3","Neck","Neck1","Head","LeftShoulder","LeftArm","LeftForeArm","LeftHand","RightShoulder","RightArm","RightForeArm","RightHand","LeftUpLeg","LeftLeg","LeftFoot","LeftToeBase","RightUpLeg","RightLeg","RightFoot","RightToeBase"]
Constraints to respect: Elbows (LeftForeArm, RightForeArm) and knees (LeftLeg, RightLeg) are hinge joints — only the local Y axis rotates; local X/Z are locked by Limit Rotation. Do not change any bone locations or scales.
Output requirements:
1.	Output Python code only, no prose. Base it on the apply_pose_template.py pattern (pose in degrees converted to radians; local XYZ Euler per bone).
2.	Fill a POSE_DEGREES dict with per-bone [x_deg, y_deg, z_deg] relative to the bone’s rest pose (not world).
3.	Keep Hips location unchanged. Small hip/spine rotations are fine if the image suggests them.
4.	Elbows/Knees: write Y only; set X=Z=0. Use image cues (limb foreshortening) to estimate flexion angles.
5.	Shoulders/UpLegs: estimate reasonable XYZ to match abduction/adduction and twist. Avoid extreme values unless clearly present.
6.	Head/Neck: infer pitch/yaw/roll; distribute some rotation to Neck/Neck1, with the remainder in Head.
7.	Do not add or rename bones; don’t touch fingers or weapon bones.
8.	Keep values in safe human ranges:
o	Elbow/Knee Y: ~0°–150° flexion
o	Shoulder: abduction 0°–120°, flexion 0°–150°, twist ±90°
o	Hip: flexion 0°–120°, ab/adduction ±45°, twist ±60°
9.	At the end, call main() so the script runs when pasted into Blender.
Helpful notes:
•	The armature already uses XYZ Euler and has Limit Scale = 1 on all bones.
•	If uncertain, bias toward conservative angles and keep the spine subtle.
Return only the final Python script.